/* autogenerated by Processing revision 1292 on 2023-04-15 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import org.ejml.*;
import org.ejml.dense.row.*;
import org.ejml.dense.row.decompose.*;
import org.ejml.dense.row.decompose.hessenberg.*;
import org.ejml.dense.row.decompose.qr.*;
import org.ejml.dense.row.decompose.chol.*;
import org.ejml.dense.row.decompose.lu.*;
import org.ejml.dense.row.linsol.*;
import org.ejml.dense.row.linsol.qr.*;
import org.ejml.dense.row.linsol.chol.*;
import org.ejml.dense.row.linsol.lu.*;
import org.ejml.dense.row.mult.*;
import org.ejml.dense.row.misc.*;
import org.ejml.dense.row.factory.*;
import org.ejml.interfaces.decomposition.*;
import org.ejml.interfaces.*;
import org.ejml.interfaces.linsol.*;
import org.ejml.sparse.*;
import org.ejml.concurrency.*;
import org.ejml.ops.*;
import org.ejml.data.*;
import org.ejml.masks.*;
import pabeles.concurrency.*;
import org.ejml.generic.*;
import org.ejml.dense.fixed.*;
import org.ejml.dense.block.*;
import org.ejml.dense.block.decomposition.hessenberg.*;
import org.ejml.dense.block.decomposition.bidiagonal.*;
import org.ejml.dense.block.decomposition.qr.*;
import org.ejml.dense.block.decomposition.chol.*;
import org.ejml.dense.block.linsol.qr.*;
import org.ejml.dense.block.linsol.chol.*;
import org.ejml.dense.row.decomposition.*;
import org.ejml.dense.row.decomposition.eig.*;
import org.ejml.dense.row.decomposition.eig.watched.*;
import org.ejml.dense.row.decomposition.eig.symm.*;
import org.ejml.dense.row.decomposition.hessenberg.*;
import org.ejml.dense.row.decomposition.bidiagonal.*;
import org.ejml.dense.row.decomposition.svd.*;
import org.ejml.dense.row.decomposition.svd.implicitqr.*;
import org.ejml.dense.row.decomposition.qr.*;
import org.ejml.dense.row.decomposition.chol.*;
import org.ejml.dense.row.decomposition.lu.*;
import org.ejml.dense.row.linsol.svd.*;
import org.ejml.sparse.csc.decomposition.qr.*;
import org.ejml.sparse.csc.decomposition.chol.*;
import org.ejml.sparse.csc.decomposition.lu.*;
import org.ejml.sparse.csc.*;
import org.ejml.sparse.csc.linsol.qr.*;
import org.ejml.sparse.csc.linsol.chol.*;
import org.ejml.sparse.csc.linsol.lu.*;
import org.ejml.sparse.csc.mult.*;
import org.ejml.sparse.csc.misc.*;
import org.ejml.sparse.csc.factory.*;
import org.ejml.sparse.triplet.*;
import org.ejml.equation.*;
import org.ejml.simple.*;
import org.ejml.simple.ops.*;

import oscP5.*;
import netP5.*;
import controlP5.*;
import java.util.*;
import java.util.Collections;
import java.awt.Polygon;
import java.awt.geom.Point2D;
import java.awt.geom.Path2D;
import java.awt.Rectangle;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Ellipse2D;
import java.util.Arrays;
import java.net.InetAddress;
import java.net.UnknownHostException;
import com.oblac.nomen.*;
import com.oblac.nomen.data.*;
import processing.pdf.*;
import org.ejml.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class lidarTrackingServer_v061 extends PApplet {

























ControlP5 cp5;

///OSC variables
int lidarPort1 = 8000;

String connectPattern = "/server/connect";
String serverIP = "localhost";
NetAddress serverLocation; 
int connectPort = 8000;
String connectMessage = "/server/connect";

int broadcastPort = 9000;
OscP5 lidarFeed1;
OscP5 lidarFeed2;
OscP5 trackDataOutput;

NetAddressList broadcastList = new NetAddressList();
///OSC variables

///setting IRL scale and drawing scale

float displayscaleFactor = 0.02f;
///setting IRL scale and drawing scale

PrintWriter writeFile;
 

float trackPointJoinDis = 100.0f;
int maxTrackPoints = 60;
float persistTolerance = 60.0f;
int minBlobPoints = 3;
int maxBlobPoints = 100;

int clipPlane = 5000;
int l1x = 10000;
int l1y = 10000;
float l1Rot = 0.0f;
int l2x = 10000;
int l2y = 10000;
float l2Rot = 0.0f;
int panX =0;
int panY =0;
int ptMin;

int sensorCount =0;
ArrayList<KeyPoint> kps = new ArrayList<KeyPoint>();

long lastFrame = 0;
int drawMode = 0; 
boolean buffersReady = false;
//0= just draw points , 1= make the backgroudn poly, 2 = track

JSONObject cVals;

TrackPoly tZone = new TrackPoly();
ArrayList<TrackPoly> iZones = new ArrayList<TrackPoly>();
ArrayList<SensorZone> sensorZones = new ArrayList<SensorZone>();

boolean sensorZoneFirstPoint = true;
boolean createSensorZone = false;
int szNumber=0;

int outWinX;
int outWinY;

TrackWindow sendWindow = new TrackWindow(0,0);

boolean izFirstPoint = true;
boolean createIgnore = false;
boolean createZone = false;
boolean prevCreate = false;
boolean createKP = false;
boolean showRays = false;
boolean showRawPoints = true;

int totalFrames = 10;
int frameCount = 0;
boolean record = false;
boolean firstFrame = true;
String folderTarget;
boolean connectDots = false;
boolean showBlobs = true;

int superSamp = 10;

int sx = 800;

int blobID = 0;
PointStream lidarPoints1 = new PointStream(4,"/lidar1",color(255,0,0));

PFont p;
PFont p2;
ControlFont font;
ControlFont smallfont;
int slPos=25;
int slSpacing = 25;


static final String LOCAL_IP = findLanIp();


PImage controlMenu;
boolean menuToggle = false;

int outSizeX = 1920;
int outSizeY = 1080;
int wPointCount = 0;
float winX1;
float winY1;
float winX2;
float winY2;
boolean createWindow = false;

public void settings()
{
size(1800,2000,P2D);


}

public void setup() 
{
  windowResizable(true);
controlMenu = loadImage("menuControls.png");
p = createFont("Verdana",20); 
font = new ControlFont(p);

p2 = createFont("Verdana",12);
smallfont = new ControlFont(p2);

//frameRate(12);
cVals = loadJSONObject("calib.json");
///OSC properties lidar input port
 OscProperties op1 = new OscProperties();
  op1.setListeningPort(lidarPort1);
  op1.setDatagramSize(256);
  lidarFeed1 = new OscP5(this, op1);
 



createGUI();           
///////////////////////////////////////////

buffersReady=true;

////////////////////////////////////////////
//load saved points
JSONArray savedPoly = loadJSONArray("polypoints.json");
tZone.pList.clear();
for(int i=0;i<savedPoly.size();i++)
{
  JSONObject pt = savedPoly.getJSONObject(i);
  tZone.addSavedPoint(pt.getInt("x"),pt.getInt("y"));
}
 //
 JSONArray savedkeypoints = loadJSONArray("keypoints.json");
kps.clear();
for(int i=0;i<savedkeypoints.size();i++)
{
  JSONObject pt = savedkeypoints.getJSONObject(i);
  kps.add(new KeyPoint(pt.getFloat("x"),pt.getFloat("y"),displayscaleFactor,sensorCount));
     sensorCount++;
}


JSONArray savedSensorZones = loadJSONArray("szPoints.json");
for(int i=0;i<savedSensorZones.size();i++)
{
     JSONArray singleZone = savedSensorZones.getJSONArray(i);
     sensorZones.add(new SensorZone(i));     
     for(int j=0;j<singleZone.size();j++)
     {
       JSONObject points = singleZone.getJSONObject(j);   
       sensorZones.get(i).addSavedPoint(points.getInt("x"),points.getInt("y"));   
          
     }
     
szNumber++;
}

JSONArray savedMasks = loadJSONArray("maskPoints.json");
for(int i=0;i<savedMasks.size();i++)
{
     JSONArray singleZone = savedMasks.getJSONArray(i);
     iZones.add(new TrackPoly());     
     for(int j=0;j<singleZone.size();j++)
     {
       JSONObject points = singleZone.getJSONObject(j);   
       iZones.get(i).addSavedPoint(points.getInt("x"),points.getInt("y"));   
          
     }
     
}
JSONArray savedWindow = loadJSONArray("windowpoints.json");
JSONObject res = savedWindow.getJSONObject(savedWindow.size()-1);

sendWindow = new TrackWindow(res.getInt("resX"),res.getInt("resY"));
for(int i=0;i<savedWindow.size()-1;i++)
{
  JSONObject pt = savedWindow.getJSONObject(i);
  sendWindow.addSavedPoint(pt.getInt("x"),pt.getInt("y"));
}


//windowResize(w, h)


     
connectClient(LOCAL_IP);
}

public void draw() 
{
background(255);

  if (menuToggle) {
    image(controlMenu, width - 200, 0);
  }

  showIPinfo();

  if (createZone || createIgnore || createSensorZone || createKP || createWindow) {
    

    String modeText = "";
    int modeColor = color(0);

    if (createZone) {
      modeText = "Create Zone";
      modeColor = color(0, 255, 0);
    } else if (createIgnore) {
      modeText = "Create Ignore Zone";
      modeColor = color(255, 0, 0);
    } else if (createSensorZone) {
      modeText = "Create Sensor Zone";
      modeColor = color(0, 0, 255);
    } else if (createKP) {
      modeText = "Create Key Point";
      modeColor = color(255, 165, 0);
    } else if (createWindow) {
      modeText = "Create Window";
      modeColor = color(151, 17, 247);
    }

    stroke(modeColor);
    strokeWeight(50);
    noFill();
    rectMode(CORNER);
    rect(0, 0, width, height);
    text(modeText, width / 2, height / 2);
  }

  tZone.display(displayscaleFactor, color(0, 255, 0));
  tZone.sendPoints();

  int redColor = color(255, 0, 0);
  for (TrackPoly iz : iZones) {
    iz.display(displayscaleFactor, redColor);
  }

  int blueColor = color(0, 0, 255);
  int blueTransparent = color(0, 0, 255, 50);
  for (SensorZone sz : sensorZones) {
    sz.display(displayscaleFactor, blueColor, blueTransparent, lidarPoints1);
  }

  for (KeyPoint pt : kps) {
    pt.display(displayscaleFactor);
  }

  if (lidarPoints1.available) {
    lidarPoints1.show();
    lidarPoints1.connect(kps);
  }

  if (sendWindow.pList.size() > 0) {
    int purpleColor = color(151, 17, 247);
    sendWindow.display(displayscaleFactor, purpleColor, lidarPoints1);
    sendWindow.sendPoints();
  }





}





public void mousePressed()
{

if(mouseButton == RIGHT)
{
     if(createZone)
     {
     tZone.addPoint(mouseX,mouseY,displayscaleFactor);
     }
     if(createIgnore)
     {
     iZones.get(iZones.size()-1).addPoint(mouseX,mouseY,displayscaleFactor);
     }
     if(createSensorZone)
     {
     sensorZones.get(sensorZones.size()-1).addPoint(mouseX,mouseY,displayscaleFactor);
     }

     if(createKP)
     {
     kps.add(new KeyPoint(mouseX,mouseY,displayscaleFactor,sensorCount));
     sensorCount++;
     }

     if(createWindow)
     {
          if(wPointCount==0)
          {
               winX1 = mouseX;
               winY1 = mouseY;
               wPointCount++;
          }
          else 
          {
               sendWindow = new TrackWindow(outWinX,outWinY);


               
               sendWindow.addPoint(round(winX1),round(winY1),displayscaleFactor);
               sendWindow.addPoint(mouseX,round(winY1),displayscaleFactor); 
               sendWindow.addPoint(mouseX,round(winY1+(((mouseX-winX1)*outWinY)/outWinX)),displayscaleFactor); 
               sendWindow.addPoint(round(winX1),round(winY1+(((mouseX-winX1)*outWinY)/outWinX)),displayscaleFactor); 
               createWindow=false;
               wPointCount=0; 
               saveCalibration(); 
          }
     }
}



}



public static final String findLanIp() 
{
  try {
    return InetAddress.getLocalHost().getHostAddress();
  }
  catch (final UnknownHostException notFound) {
    System.err.println("No LAN IP found!");
    return "";
  }
}

public void showIPinfo()
{
fill(0);
textSize(30);
textAlign(LEFT,BOTTOM);
text(LOCAL_IP+" : "+broadcastPort,10,height-20);

}


/**
 * keyPressed: This function handles various key press events.
 * s: Save the current calibration.
 * t: Toggle create tracking zone mode.
 * m: Toggle create ignore zone mode.
 * M: Remove the last created ignore zone.
 * z: Toggle create sensor zone mode.
 * Z: Remove the last created sensor zone.
 * r: Toggle displaying rays.
 * b: Toggle displaying raw points.
 * c: Toggle connect dots mode.
 * B: Toggle displaying blobs.
 * x: Clear all keypoints, tracking zones, ignore zones, and sensor zones.
 * k: Toggle create key point mode.
 * K: Remove the last created key point.
 * h: Toggle menu display.
 * w: Toggle create window mode.
 * W: Clear the send window.
 */
public void keyPressed() {
  switch (key) {
    case 'f':
      clearAll();
      fitToCanvas();
      break;
    case 's':
      saveCalibration();
      break;
    case 't':
      handleCreateZone();
      break;
    case 'm':
      handleCreateIgnore();
      break;
    case 'M':
      handleRemoveIgnore();
      break;
    case 'z':
      handleCreateSensorZone();
      break;
    case 'Z':
      handleRemoveSensorZone();
      break;
    case 'r':
      showRays = !showRays;
      break;
    case 'b':
      showRawPoints = !showRawPoints;
      break;
    case 'c':
      connectDots = !connectDots;
      break;
    case 'B':
      showBlobs = !showBlobs;
      break;
    case 'x':
      clearAll();
      break;
    case 'k':
      createKP = !createKP;
      break;
    case 'K':
      removePoint(kps);
      break;
    case 'h':
      menuToggle = !menuToggle;
      break;
    case 'w':
      handleCreateWindow();
      break;
    case 'W':
      handleClearWindow();
      break;
  }
}
public void fitToCanvas() {
  PointSet currentPoints = lidarPoints1.getDrawPoints();
  float minX = Float.MAX_VALUE;
  float minY = Float.MAX_VALUE;
  float maxX = Float.MIN_VALUE;
  float maxY = Float.MIN_VALUE;

  for (LidarPoint lp : currentPoints.ldPoints) {
    float x = (float) lp.world.getX();
    float y = (float) lp.world.getY();
    minX = min(minX, x);
    minY = min(minY, y);
    maxX = max(maxX, x);
    maxY = max(maxY, y);
  }

  float rangeX = maxX - minX;
  float rangeY = maxY - minY;

  if (rangeX > 0 && rangeY > 0) {
    float scaleX = width / rangeX;
    float scaleY = height / rangeY;
    float newScaleFactor = min(scaleX, scaleY) * 0.9f; // Add a margin by multiplying by 0.9

    float centerX = (minX + maxX) / 2;
    float centerY = (minY + maxY) / 2;

    cp5.getController("l1x").setValue(((width / 2) - centerX * newScaleFactor)+width/2);
    cp5.getController("l1y").setValue(((height / 2) - centerY * newScaleFactor)+height/2);
    cp5.getController("displayscaleFactor").setValue(newScaleFactor);
  }
}
public void handleCreateZone() {
  if (!createZone) {
    tZone = new TrackPoly();
  }
  createZone = !createZone;
  saveCalibration();
}

public void handleCreateIgnore() {
  if (!createIgnore && izFirstPoint) {
    iZones.add(new TrackPoly());
  }
  createIgnore = !createIgnore;
  izFirstPoint = !izFirstPoint;
  saveCalibration();
}

public void handleRemoveIgnore() {
  if (iZones.size() > 0) {
    iZones.remove(iZones.size() - 1);
    saveCalibration();
  }
}

public void handleCreateSensorZone() {
  if (!createSensorZone && sensorZoneFirstPoint) {
    sensorZones.add(new SensorZone(szNumber));
    szNumber++;
  }
  createSensorZone = !createSensorZone;
  sensorZoneFirstPoint = !sensorZoneFirstPoint;
  saveCalibration();
}

public void handleRemoveSensorZone() {
  if (sensorZones.size() > 0) {
    sensorZones.remove(sensorZones.size() - 1);
    szNumber--;
    saveCalibration();
  }
}
public void clearAll() {
  kps.clear();
  tZone.pList.clear();
  tZone.trackArea = new Polygon();
  sensorCount = 0;
  iZones.clear();
  sensorZones.clear();
  szNumber = 0;
  saveCalibration();
}

public void handleCreateWindow() {
  createWindow = !createWindow;
  if (!createWindow) {
    wPointCount = 0;
  }
}

public void handleClearWindow() {
  sendWindow = new TrackWindow(0, 0);
  saveCalibration();
}



public void saveCalibration()
{
     

     cVals = new JSONObject();
     cVals.setInt("clipPlane", clipPlane);
     cVals.setInt("l1x",l1x);
     cVals.setInt("l1y",l1y);
     cVals.setFloat("l1Rot",l1Rot);
     cVals.setInt("l2x",l2x);
     cVals.setInt("l2y",l2y);
     cVals.setFloat("l2Rot",l2Rot);
     cVals.setFloat("displayscaleFactor",displayscaleFactor);
     cVals.setInt("minBlobPoints",minBlobPoints);
     cVals.setInt("maxBlobPoints",maxBlobPoints);

     saveJSONObject(cVals, "data/calib.json");


     JSONArray polyPoints = new JSONArray();
     int arrayIndex = 0;
     for(PolyPoint pt : tZone.pList)
     {
      JSONObject pointData = new JSONObject();
      pointData.setInt("x",pt.worldX);
      pointData.setInt("y",pt.worldY);
      polyPoints.setJSONObject(arrayIndex,pointData);
      arrayIndex++;
     }
     saveJSONArray(polyPoints, "data/polypoints.json");



     JSONArray allSenseZones = new JSONArray();
     for(int i=0;i<sensorZones.size();i++)
     {

     polyPoints = new JSONArray();
     arrayIndex = 0;
     for(PolyPoint pt : sensorZones.get(i).pList)
     {
      JSONObject pointData = new JSONObject();
      pointData.setInt("x",pt.worldX);
      pointData.setInt("y",pt.worldY);
      polyPoints.setJSONObject(arrayIndex,pointData);
      arrayIndex++;
     }
     allSenseZones.setJSONArray(i,polyPoints);
     }
     saveJSONArray(allSenseZones, "data/szPoints.json");

     JSONArray allMaskZones = new JSONArray();
     for(int i=0;i<iZones.size();i++)
     {

     polyPoints = new JSONArray();
     arrayIndex = 0;
     for(PolyPoint pt : iZones.get(i).pList)
     {
      JSONObject pointData = new JSONObject();
      pointData.setInt("x",pt.worldX);
      pointData.setInt("y",pt.worldY);
      polyPoints.setJSONObject(arrayIndex,pointData);
      arrayIndex++;
     }
     allMaskZones.setJSONArray(i,polyPoints);
     }
     saveJSONArray(allMaskZones, "data/maskPoints.json");



     JSONArray kPoints = new JSONArray();
     arrayIndex = 0;
     for(KeyPoint k : kps)
     {
      JSONObject pointData = new JSONObject();
      pointData.setFloat("x",k.pixelX);
      pointData.setFloat("y",k.pixelY);
      pointData.setInt("number",k.sNumber);
      kPoints.setJSONObject(arrayIndex,pointData);
      arrayIndex++;
     }
     saveJSONArray(kPoints, "data/keypoints.json");


     JSONArray windowPoints = new JSONArray();
     arrayIndex = 0;
     for(PolyPoint pt : sendWindow.pList)
     {
      JSONObject pointData = new JSONObject();
      pointData.setInt("x",pt.worldX);
      pointData.setInt("y",pt.worldY);
      windowPoints.setJSONObject(arrayIndex,pointData);
      arrayIndex++;
     }
     JSONObject resData = new JSONObject();
     resData.setInt("resX",sendWindow.resolutionX);
     resData.setInt("resY",sendWindow.resolutionY);
     windowPoints.setJSONObject(arrayIndex,resData);
     saveJSONArray(windowPoints, "data/windowpoints.json");

  

}
public void createGUI()
{
cp5 = new ControlP5(this);
cp5.setFont(font);
Group calibration = cp5.addGroup("calibration")
               .setPosition(0,slPos)
                .activateEvent(false)
                .setBarHeight(130)
                .setBackgroundColor(color(0,0,0,80))
                .setWidth(width)
                .setBackgroundHeight(300)
                .setLabel("calibration")
                ;

cp5.addSlider("clipPlane")
     .setPosition(10,slPos)
     .setSize(sx,slSpacing-1)
     .setRange(0,20000)
     .setValue(cVals.getInt("clipPlane"))
     .setDecimalPrecision(0)
     .setGroup(calibration)
     ;
cp5.addSlider("trackPointJoinDis")
     .setPosition(10,slPos+=slSpacing)
     .setSize(sx,slSpacing-1)
     .setRange(0,300)
     .setValue(215)
     .setDecimalPrecision(2)
     .setGroup(calibration)
     ;
cp5.addSlider("minBlobPoints")
            .setPosition(10, slPos += slSpacing)
            .setSize(sx, slSpacing - 1)
            .setRange(2, 20)
            .setValue(cVals.getInt("minBlobPoints"))
            .setDecimalPrecision(1)
            .setGroup(calibration)
            ;
cp5.addSlider("maxBlobPoints")
            .setPosition(10, slPos += slSpacing)
            .setSize(sx, slSpacing - 1)
            .setRange(2, 200)
            .setValue(cVals.getInt("maxBlobPoints"))
            .setDecimalPrecision(1)
            .setGroup(calibration)
            ;
cp5.addSlider("persistTolerance")
     .setPosition(10,slPos+=slSpacing)
     .setSize(sx,slSpacing-1)
     .setRange(0,300)
     .setValue(250)
     .setDecimalPrecision(2)
     .setGroup(calibration)
     ;
cp5.addSlider("displayscaleFactor")
     .setPosition(10,slPos+=slSpacing)
     .setSize(sx,slSpacing-1)
     .setRange(0.00f,0.5f)
     .setValue(cVals.getFloat("displayscaleFactor"))
     .setDecimalPrecision(2)
     .setGroup(calibration)
     ;     
cp5.addSlider("l1x")
     .setPosition(10,slPos+=slSpacing)
     .setSize(sx,slSpacing-1)
     .setRange(0,15000)
     .setValue(cVals.getInt("l1x"))
     .setDecimalPrecision(0)
     .setGroup(calibration)
     ;
cp5.addSlider("l1y")
     .setPosition(10,slPos+=slSpacing)
     .setSize(sx,slSpacing-1)
     .setRange(0,15000)
     .setValue(cVals.getInt("l1y"))
     .setDecimalPrecision(0)
     .setGroup(calibration)
     ;
cp5.addSlider("l1Rot")
     .setPosition(10,slPos+=slSpacing)
     .setSize(sx,slSpacing-1)
     .setRange(-360,360)
     .setValue(cVals.getFloat("l1Rot"))
     .setDecimalPrecision(1)
     .setGroup(calibration)
     ;
cp5.addSlider("outWinX")
     .setPosition(10,slPos+=slSpacing)
     .setSize(sx,slSpacing-1)
     .setRange(0,4000)
     .setValue(1920)
     .setDecimalPrecision(1)
     .setGroup(calibration)
     ;
cp5.addSlider("outWinY")
     .setPosition(10,slPos+=slSpacing)
     .setSize(sx,slSpacing-1)
     .setRange(0,4000)
     .setValue(1080)
     .setDecimalPrecision(1)
     .setGroup(calibration)
     ;

cp5.setFont(smallfont);
// Add buttons to the group
int buttonWidth = 200;
int buttonHeight = 20;

slPos += slSpacing; // Add spacing after the last slider

cp5.addButton("FitToScreen")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("FIT")
  ;//.setCaptionLabel("scale points to fit screen");

cp5.addButton("SaveCalibration")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Save Calibration")
  ;//.setCaptionLabel("Save current calibration settings");

cp5.addButton("ToggleCreateTrackingZone")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Toggle Tracking Zone")
  ;//.setCaptionLabel("Toggle creating tracking zones");

cp5.addButton("ToggleCreateIgnoreZone")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Toggle Ignore Zone")
  ;//.setCaptionLabel("Toggle creating ignore zones");

cp5.addButton("RemoveIgnoreZone")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Remove Ignore Zone")
  ;//.setCaptionLabel("Remove the selected ignore zone");

cp5.addButton("ToggleCreateSensorZone")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Toggle Sensor Zone")
  ;//.setCaptionLabel("Toggle creating sensor zones");

cp5.addButton("RemoveSensorZone")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Remove Sensor Zone")
  ;//.setCaptionLabel("Remove the selected sensor zone");

cp5.addButton("ToggleDisplayRays")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Toggle Display Rays")
  ;//.setCaptionLabel("Toggle the display of rays");

cp5.addButton("ToggleDisplayRawPoints")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Toggle Raw Points")
  ;//.setCaptionLabel("Toggle the display of raw points");

cp5.addButton("ToggleConnectDots")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Toggle Connect Dots")
  ;//.setCaptionLabel("Toggle connecting dots in clusters");

cp5.addButton("ToggleDisplayBlobs")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Toggle Display Blobs")
  ;//.setCaptionLabel("Toggle the display of blobs");

cp5.addButton("ClearAll")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Clear All")
  ;//.setCaptionLabel("Clear all zones, keypoints, and windows");

cp5.addButton("ToggleCreateKeypoint")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Toggle Keypoint")
  ;//.setCaptionLabel("Toggle creating keypoints");

cp5.addButton("RemoveKeypoint")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Remove Keypoint")
  ;//.setCaptionLabel("Remove the selected keypoint");

cp5.addButton("ToggleMenu")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Toggle Menu")
  ;//.setCaptionLabel("Toggle the display of the menu");

cp5.addButton("ToggleCreateWindow")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Toggle Create Window")
  ;//.setCaptionLabel("Toggle creating windows");

cp5.addButton("ClearWindow")
  .setPosition(10, slPos += slSpacing)
  .setSize(buttonWidth, buttonHeight)
  .setGroup(calibration)
  .setLabel("Clear Window")
  ;//.setCaptionLabel("Clear the selected window");



}
public void controlEvent(ControlEvent event) {
  String buttonName = event.getController().getName();

  if (buttonName.equals("FitToScreen")) {
    fitToCanvas();;
  } else if (buttonName.equals("SaveCalibration")) {
    saveCalibration();
  } else if (buttonName.equals("ToggleCreateTrackingZone")) {
    handleCreateZone();
  } else if (buttonName.equals("ToggleCreateIgnoreZone")) {
    handleCreateIgnore();
  } else if (buttonName.equals("RemoveIgnoreZone")) {
    handleRemoveIgnore();
  } else if (buttonName.equals("ToggleCreateSensorZone")) {
    handleCreateSensorZone();
  } else if (buttonName.equals("RemoveSensorZone")) {
    handleRemoveSensorZone();
  } else if (buttonName.equals("ToggleDisplayRays")) {
    showRays = !showRays;
  } else if (buttonName.equals("ToggleDisplayRawPoints")) {
    showRawPoints = !showRawPoints;
  } else if (buttonName.equals("ToggleConnectDots")) {
    connectDots = !connectDots;
  } else if (buttonName.equals("ToggleDisplayBlobs")) {
    showBlobs = !showBlobs;
  } else if (buttonName.equals("ClearAll")) {
    clearAll();
  } else if (buttonName.equals("ToggleCreateKeypoint")) {
    createKP = !createKP;
  } else if (buttonName.equals("RemoveKeypoint")) {
    removePoint(kps);
  } else if (buttonName.equals("ToggleMenu")) {
    menuToggle = !menuToggle;
  } else if (buttonName.equals("ToggleCreateWindow")) {
    handleCreateWindow();
  } else if (buttonName.equals("ClearWindow")) {
    handleClearWindow();
  }
}
class KeyPoint
{
  float pixelX;
  float pixelY;
  int xPos;
  int yPos;
  int sNumber;
  Point2D center;
  KeyPoint(float _xp, float _yp, float sf, int _sn)
  {
    pixelX = _xp;
    pixelY = _yp;
    xPos=round(_xp/sf);
    yPos=round(_yp/sf);

    center = new Point2D.Float(_xp/sf,_yp/sf);
    sNumber = _sn;
  }

  public void display(float drawScale)
  {
    noStroke();  
    fill(255,165,0);
    ellipse((float)center.getX()*drawScale,(float)center.getY()*drawScale,20,20);
    textAlign(CENTER,CENTER);
    textSize(20);
    text(("x "+xPos+"  |  y "+yPos),(float)center.getX()*drawScale,((float)center.getY()*drawScale)+25);
    text(""+sNumber,(float)center.getX()*drawScale,((float)center.getY()*drawScale)-30);

  }



}

public void removePoint(ArrayList<KeyPoint> kPoint)
{
  if(kPoint.size()>0)
  {
    kPoint.remove(kPoint.size()-1);
    sensorCount = kPoint.size();
  }


}
class LidarPoint implements Comparable<LidarPoint>
{
  Point2D local;
  Point2D world;

  float angle;
  float dist;
  float originX;
  float originY;
  
  boolean bgPoint;
  
    LidarPoint(float in_angle, float in_dist, float worldPosX, float worldPosY)
    {
      
      
        ///come back to this seems like an error check 
        //maxDist = (lidarDistance>maxDist) ? lidarDistance : maxDist;
        float localX = 0 + in_dist * sin(radians(in_angle));
        float localY = 0 - in_dist * cos(radians(in_angle)); 
        local = new Point2D.Float(localX,localY);

      
      //angle = (in_angle > 0) ? in_angle : (360+in_angle);
      angle = in_angle;
      dist = in_dist;
      originX = worldPosX;
      originY = worldPosY;
      float wx = localX+worldPosX;
      float wy = localY+worldPosY;

      world = new Point2D.Float(wx,wy);

      //println(localX+"\t"+localY+"\t"+wx+"\t"+wy);
    }


////to use this:  Collections.sort(ldPoints);
  @Override public 
    int compareTo(LidarPoint other) 
    {
      return Float.compare(this.angle,other.angle);
    } 

  public void display(float drawScale, int dotColor, boolean drawAsNumbers)
  {
    fill(dotColor);
    noStroke();
      //ellipse(ctrX+map(xPos, 0.0f , scaleFactor, 0.0f, width/2.0f),ctrY+map(yPos, 0.0f , scaleFactor, 0.0f, width/2.0f),width/200,width/200);
     if(drawAsNumbers)
     {
       textAlign(CENTER,CENTER);
       textSize(10);
       text(""+angle,(float)world.getX()*drawScale,(float)world.getY()*drawScale);


     }
     else
     {
      ellipse((float)world.getX()*drawScale,(float)world.getY()*drawScale,width/500,width/500);
      
      if(showRays)
      {
      stroke(dotColor);
      strokeWeight(0.3f);
      line(originX*drawScale,originY*drawScale,(float)world.getX()*drawScale,(float)world.getY()*drawScale);
      }
     }
  }  


  public void adjust(float adjDist, float clipRad)
  {
    dist = (dist<clipRad) ? dist : clipRad;

    dist += adjDist;
    float localX = 0 + dist * sin(radians(angle));
    float localY = 0 - dist * cos(radians(angle)); 
    local.setLocation(localX,localY);
    
    world.setLocation((originX+localX),(originY+localY));

  }
  
  
}
class LidarData {
  String oscAddress;
  int pointColor;
  float ox;
  float oy;
  float rAdjust;

  LidarData(String oscAddress, int pointColor, float ox, float oy, float rAdjust) {
    this.oscAddress = oscAddress;
    this.pointColor = pointColor;
    this.ox = ox;
    this.oy = oy;
    this.rAdjust = rAdjust;
  }
}
class PointStream
{
int totalFeeds;
int bufferSlots;
PointSet pointBuffer;
ArrayList<TrackBlob> prevBlobs = new ArrayList<TrackBlob>();
ArrayList<TrackBlob> currentBlobs = new ArrayList<TrackBlob>();
DrawBuffer activePoints;
int fillCount;
int streamColor;
String oscTag;
int startPoint;
int prevPoint;
int currentWrite =0;

int ssCount = 0;
PointSet ssPoints = new PointSet(0,0, color(0,0,0), 0);

private static final int FILL_COUNT_THRESHOLD = 4;

boolean available = false;
PointStream(int bufferSize, String prefix, int dCol)
{
//pointBuffer = new PointSet(0,0,dCol,fillCount);
oscTag=prefix;
activePoints = new DrawBuffer(bufferSize);
bufferSlots = bufferSize;
fillCount=0;
  for(int i =0;i<bufferSize;i++)
  {
    fillCount++;
    activePoints.pts.add(new PointSet(0.0f, 0.0f, streamColor, fillCount));
  }

}
public void packagePoints(float ldrAngle, int ldrDistance, int pointNumber, float farClip, int lidarNumber, float ox, float oy, float rAdjust) {
    // Check if buffers are ready
    if (buffersReady) {
        PointSet pointBuffer = activePoints.pts.get(currentWrite);
        pointBuffer.originX = ox;
        pointBuffer.originY = oy;
        pointBuffer.angleAdjust = rAdjust;

        pointBuffer.lidarNumber = lidarNumber;
        // Check if the point is within the far clip distance
        if (ldrDistance <= farClip) {
            LidarPoint bufferPoint = new LidarPoint(ldrAngle + pointBuffer.angleAdjust, ldrDistance, pointBuffer.originX, pointBuffer.originY);

            // Check if the point number is greater than the previous point number or if the buffer is empty
            if ((pointNumber > prevPoint) || (pointBuffer.ldPoints.size() == 0)) {
                // Add the point to the current active slot
                pointBuffer.addPoint(bufferPoint);
            } else {
                // Update the current write index, clear it, and add the point
                updateCurrentWriteIndex(pointBuffer);
                activePoints.pts.get(currentWrite).addPoint(bufferPoint);
            }

            prevPoint = pointNumber;
        }
    }
}


private void updateCurrentWriteIndex(PointSet pointBuffer) {
    // Update fill count and set 'available' if the threshold is exceeded
    fillCount++;
    if (fillCount > FILL_COUNT_THRESHOLD) {
        available = true;
    }
    // Set the birthday for the current point set
    pointBuffer.birthday = fillCount;

    // Update the current write index and clear the corresponding PointSet
    currentWrite = find(0);
    activePoints.pts.get(currentWrite).ldPoints.clear();
}







public PointSet getDrawPoints() {
    PointSet newestPointSet = null;
    Iterator<PointSet> iterator = activePoints.pts.iterator();

    while (iterator.hasNext()) {
        PointSet pointSet = iterator.next();

        if (newestPointSet == null || pointSet.birthday > newestPointSet.birthday) {
            newestPointSet = pointSet;
        }
    }

    return newestPointSet != null ? newestPointSet : new PointSet(0, 0, color(0, 0, 0), 0);
}






  public void show()
  {
    
    
    
    PointSet freshPoints = getDrawPoints();
        if(freshPoints.ldPoints.size()>0)
        {
          if(connectDots)
          {
          freshPoints.connect(displayscaleFactor,color(0,0,0,50),3);
          }

          if(showRawPoints)
            {
              for(LidarPoint pt : freshPoints.ldPoints)
              {
              pt.display(displayscaleFactor,freshPoints.dotColor,false);
              }  
            }

          if(showBlobs)
          {
            ArrayList<TrackBlob> freshBlobs = sortToBlobs(freshPoints.ldPoints,trackPointJoinDis,tZone.trackArea,iZones,maxBlobPoints);
            currentBlobs.clear();
            currentBlobs = checkPersistance(freshBlobs,prevBlobs,persistTolerance);

            OscMessage blobData = new OscMessage("/blobs");
            blobData.add(currentBlobs.size());  //0
            for(TrackBlob tb : currentBlobs)
              {
              tb.display(displayscaleFactor,true,true,true,streamColor);
              //send the blob data
              blobData.add(tb.name);//1
              blobData.add(tb.blobNumber);//2
              blobData.add((float)tb.center.getX());//3
              blobData.add((float)tb.center.getY());//4
              blobData.add((float)tb.boundingBox.getWidth());//5
              blobData.add((float)tb.boundingBox.getHeight());//6
              blobData.add(tb.life);//7
              blobData.add(tb.distanceTraveled*1000);//8

              float pixelX = (float)tb.center.getX()*displayscaleFactor;
              float pixelY = (float)tb.center.getY()*displayscaleFactor;

              float wpX1 = tZone.pList.get(0).worldX*displayscaleFactor;
              float wpY1 = tZone.pList.get(0).worldY*displayscaleFactor;
              float wpX2 = tZone.pList.get(2).worldX*displayscaleFactor;
              float wpY2 = tZone.pList.get(2).worldY*displayscaleFactor;
              
              float relX = map((pixelX-wpX1),0,(wpX2-wpX1),0,outSizeX);
              float relY = map((pixelY-wpY1),0,(wpY2-wpY1),0,outSizeY);
              
              }
              lidarFeed1.send(blobData,broadcastList);
              


              prevBlobs.clear();
              prevBlobs.addAll(currentBlobs);  

          }
        }
      }

    public ArrayList<TrackBlob> sortToBlobs(ArrayList<LidarPoint> rawPts, float jTolerance, Polygon testArea, ArrayList<TrackPoly> igZones, int maxPointsPerBlob) {
    ArrayList<LidarPoint> bgFilteredPts = new ArrayList<LidarPoint>();

    // Iterate through raw LIDAR points
    for (LidarPoint testPt : rawPts) {
        boolean ignorePoint = false;

        // Check if the point is within the tracking area
        if (testArea.contains(testPt.world)) {
            // Check if the point is within any of the ignore zones
            for (TrackPoly igZone : igZones) {
                if (igZone.trackArea.contains(testPt.world)) {
                    ignorePoint = true;
                    break;
                }
            }

            // If the point should be ignored, skip the rest of the current iteration
            if (ignorePoint) {
                continue;
            }

            // Add the point to the filtered points list if it passes the checks
            bgFilteredPts.add(testPt);
        }
    }

    ArrayList<TrackBlob> blobList = new ArrayList<TrackBlob>();
    boolean currentlyAdding = false;

    // Iterate through the filtered points
    for (int i = 0; i < (bgFilteredPts.size() - 1); i++) {
        // Calculate the distance between the current point and the next point
        double testDist = bgFilteredPts.get(i).world.distance(bgFilteredPts.get(i + 1).world);

        // Check if the distance is less than or equal to the tolerance
        if ((float) testDist <= jTolerance) {
            // Add a new blob if not currently adding or if the current blob is full
            if (!currentlyAdding || blobList.get(blobList.size() - 1).totalPoints >= maxPointsPerBlob) {
                blobList.add(new TrackBlob());
                blobList.get(blobList.size() - 1).addPoint(bgFilteredPts.get(i));
                currentlyAdding = true;
            }
            // Add the next point to the current blob
            blobList.get(blobList.size() - 1).addPoint(bgFilteredPts.get(i + 1));
        } else {
            // Set currentlyAdding to false if the distance is greater than the tolerance
            currentlyAdding = false;
        }
    }


// Check if there is more than one blob in the list
if (blobList.size() > 1) {
    // Get the index of the last blob in the list
    int lastBlob = blobList.size() - 1;
    // Get the index of the last point in the last blob
    int lastPoint = blobList.get(lastBlob).blobPoints.size() - 1;

    // Calculate the distance between the last point of the last blob and the first point of the first blob
    double edgeDistance = blobList.get(lastBlob).blobPoints.get(lastPoint).world.distance(blobList.get(0).blobPoints.get(0).world);

    // Check if the distance is less than or equal to the tolerance
    if ((float) edgeDistance <= jTolerance) {
        // If the distance is within tolerance, merge the first blob into the last blob
        for (LidarPoint ep : blobList.get(0).blobPoints) {
            blobList.get(lastBlob).addPoint(ep);
        }
        // Remove the first blob from the list after merging
        blobList.remove(0);
    }
}


    //remove blobs with too few points
    for(int i=0;i<blobList.size();i++)
    {
      if(blobList.get(i).totalPoints<=minBlobPoints)
      {
        blobList.remove(i);
      }
    }



return blobList;


}
 
public void connect(ArrayList<KeyPoint> kp)
{
     OscMessage dsData = new OscMessage("/distanceSensors");
    
     dsData.add(kp.size()); //0
     dsData.add(currentBlobs.size()); //1
     lidarFeed1.send(dsData,broadcastList);
     
     for(KeyPoint point : kp)
     {
      OscMessage ksData = new OscMessage("/distanceSensors/"+point.sNumber);
      
       ksData.add((float)point.xPos); //0
       ksData.add((float)point.yPos); //1
       
     
          for(TrackBlob blob : currentBlobs)
          {
            
            float aT = atan2((float)point.center.getY()-(float)blob.center.getY(),(float)point.center.getX()-(float)blob.center.getX());
            float angleTo = degrees(aT);
            
            
               strokeWeight(2);
               stroke(255,165,0);
               line((float)blob.center.getX()*displayscaleFactor,(float)blob.center.getY()*displayscaleFactor,(float)point.center.getX()*displayscaleFactor,(float)point.center.getY()*displayscaleFactor);
              fill(streamColor);
              float sDist = (float)blob.center.distance(point.center);
              float xp = (((float)blob.center.getX()*displayscaleFactor)+((float)point.center.getX()*displayscaleFactor))/2.0f;
              float yp = (((float)blob.center.getY()*displayscaleFactor)+((float)point.center.getY()*displayscaleFactor))/2.0f;
              text(""+sDist+" @ "+angleTo,xp,yp);

              
              ksData.add(sDist); //2
              ksData.add(angleTo); //3
              ksData.add(blob.name); //4
              ksData.add(blob.blobNumber);//5
          }
        lidarFeed1.send(ksData,broadcastList);  
     }

}
    public int find(int ageRank)
    {
      int returnIndex =0; 
      IntList bdays = new IntList();
      for(int i=0;i<activePoints.pts.size();i++)
      {
        int birthday = (int)activePoints.pts.get(i).birthday;
        bdays.append(birthday);
      }
      bdays.sort();
      int found = bdays.get(ageRank);
      for(int i=0;i<activePoints.pts.size();i++)
      {
        if((int)activePoints.pts.get(i).birthday==found)
        {
          returnIndex=i;
          break;         
        }
        
      }
      return returnIndex;


    }



}

class DrawBuffer
{
int bufferSize;
ArrayList<PointSet> pts = new ArrayList<PointSet>();
DrawBuffer(int bSize)
{
  bufferSize = bSize;


}


}



public ArrayList<TrackBlob> checkPersistance(ArrayList<TrackBlob> newBlobs, ArrayList<TrackBlob> oldBlobs, float minDistance)
{
//https://github.com/jorditost/BlobPersistence/blob/master/WhichFace/WhichFace.pde

  //measure distance from new blobs to all previous ones
  for(int nb=0;nb<newBlobs.size();nb++)
  {
  //make a list
  MeasureManager closestBlob = new MeasureManager();

    for(int ob = 0;ob<oldBlobs.size();ob++)
    {
      double measure = newBlobs.get(nb).center.distance(oldBlobs.get(ob).center);
      if((float)measure<closestBlob.distance)
      {
        closestBlob.index = ob;
        closestBlob.distance = (float)measure;
      }
    }
    //println(closestBlob.distance);
    ///see if the closest old blob is close enough to count
    if(closestBlob.distance<=minDistance)
    {
      newBlobs.get(nb).update(oldBlobs.get(closestBlob.index)); 
    }
    else
    {
      //give it a number
      
      newBlobs.get(nb).assignID();

     
    }


  }

return newBlobs;
}
class MeasureManager
{
int index;
float distance;
  MeasureManager()
  {
    distance=99999;
  }
}

public float roundTo(float thenumber, int decimalPlaces)
{
 
  String rString = nf(thenumber,0,decimalPlaces);
 float rFloat = 0;
  
 


  try{
    rFloat = Float.parseFloat(rString);
    }catch(NumberFormatException exp)
    {

    }

     return rFloat;
}




public void oscEvent(OscMessage inputData) 
{

 if(inputData.addrPattern().equals("/lidar1"))
 {
   lidarPoints1.packagePoints(inputData.get(0).floatValue(),inputData.get(1).intValue(),inputData.get(2).intValue(),clipPlane,1,l1x+panX,l1y+panY,l1Rot);
 }
else if(inputData.addrPattern().equals(connectPattern))
{
   connectClient(inputData.netAddress().address());
}


}


 private void connectClient(String theIPaddress) {
     if (!broadcastList.contains(theIPaddress, broadcastPort)) {
       broadcastList.add(new NetAddress(theIPaddress, broadcastPort));
       println("### adding "+theIPaddress+" to the list.");
     } else {
       println("### "+theIPaddress+" is already connected.");
     }
     println("### currently there are "+broadcastList.list().size()+" remote locations connected.");
 }


/*
private void disconnect(String theIPaddress) {
if (broadcastList.contains(theIPaddress, myBroadcastPort)) {
		broadcastList.remove(theIPaddress, myBroadcastPort);
       println("### removing "+theIPaddress+" from the list.");
     } else {
       println("### "+theIPaddress+" is not connected.");
     }
       println("### currently there are "+broadcastList.list().size());
 }

*/




  
/*
Track Blobs
address - "/blobs"

0 - total number of blobs currently tracked

(assuming your loop start at x=0 to read data (x*8)+?)
1 - nth blob name   
2 - nth blob ID number
3 - nth blob center X coordinate (centimeters)
4 - nth blob center X coordinate (centimeters)
5 - nth blob bounding box Width (centimeters)
6 - nth blob bounding box Height (centimeters)
7 - nth blob lifespan (seconds)
8 - nth blob distanc travelled (centimeters)

9 - nth blob name
10 - nth blob number
11 - nth blob center X coordinate (centimeters)
12 - nth blob center X coordinate (centimeters)
13 - nth blob bounding box Width (centimeters)
14 - nth blob bounding box Height (centimeters)
15 - nth blob lifespan (seconds)
16 - nth blob distanc travelled (centimeters)
...and so on for all blobs

Distance Sensors
address - "/distanceSensors"

0 - total distance sensors
1 - total number of blobs currently tracked

address - "/distanceSensors/nth distance sensor ID number"

0 - nth distance sensor X coordinate (centimeters)
1 - nth distance sensor Y coordinate (centimeters)

2 - distance to nth blob (centimeters)
3 - angle to nth blob (degrees)
4 - nth blob name
5 - nth blob ID number





*/
class PointSet
{
ArrayList<LidarPoint> ldPoints;
float originX = 0;
float originY = 0;
float angleAdjust =0;
float prevAng;
boolean firstSpin = true;
float startAngle;
int lidarNumber;
int birthday;
int dotColor;


    PointSet(float _ox, float _oy, int _sc, int _bday)
    {
    ldPoints = new ArrayList<LidarPoint>();
    originX = _ox;
    originY = _oy;
    dotColor = _sc;
    birthday = _bday;
    }

    public void addPoint(LidarPoint inPoint)
    {
            
        ldPoints.add(inPoint);
        
    }
    
    public void connect(float drawScale, int lineColor, float lineWeight)
    {
      PShape trackPoly = createShape();
        trackPoly.beginShape();
        trackPoly.stroke(lineColor);
        trackPoly.strokeWeight(lineWeight);
        trackPoly.noFill();
        for(LidarPoint p : ldPoints)
        {
            trackPoly.vertex((float)p.world.getX()*drawScale,(float)p.world.getY()*drawScale);
        }
        trackPoly.endShape(CLOSE);
        shape(trackPoly,0,0);
    }

}

class TrackBlob
{
Point2D center = new Point2D.Double(0,0);
Path2D allPoints;
Rectangle2D boundingBox;

float radius =0;
int totalPoints;

float joinRadius;
float distFromSource;
int maxPoints;

ArrayList<Point2D> locationHistory;
ArrayList<LidarPoint> blobPoints; //= new ArrayList<LidarPoint>();

String name;
int blobNumber;

float distanceTrackCalibration = 30;
/////
long birthDay;
float velocity;
double lastUpdate;
float distanceTraveled;
float life;
boolean drawLabel = true;
int labelSize = 10;

Nomen nameGenerator = new Nomen();

// new variables for velocity
  
  float velocityMagnitude;
  PVector velocityVec; // new variable to store the velocity vector
    boolean drawVelocity = true;


// KalmanFilter object
  KalmanFilter kf;
float dt = 0.1f; // time step
float r = 0.1f; // measurement noise
float q = 0.001f; // process noise

TrackBlob()
{
blobPoints = new ArrayList<LidarPoint>();
allPoints = new Path2D.Double();

locationHistory = new ArrayList<Point2D>();
locationHistory.add(new Point2D.Double());
totalPoints =0;
name = nameGenerator.animal().get();
birthDay = millis();

velocityVec = new PVector(0,0);
    velocityMagnitude = 0;

// Initialize KalmanFilter with appropriate variables
    int stateSize = 4;
    int measurementSize = 2;
    kf = new KalmanFilter(stateSize, measurementSize);
    SimpleMatrix F = new SimpleMatrix(new double[][] { 
      { 1, 0, dt, 0 }, 
      { 0, 1, 0, dt },
      { 0, 0, 1, 0 },
      { 0, 0, 0, 1 }
    });
    SimpleMatrix Q = new SimpleMatrix(new double[][] { 
      { 1, 0, 0, 0 }, 
      { 0, 1, 0, 0 },
      { 0, 0, 1, 0 },
      { 0, 0, 0, 1 }
    }).scale(q);
    SimpleMatrix H = new SimpleMatrix(new double[][] { 
      { 1, 0, 0, 0 }, 
      { 0, 1, 0, 0 }
    });
    SimpleMatrix R = new SimpleMatrix(new double[][] { 
      { r, 0 }, 
      { 0, r }
    });
    kf.setF(F);
    kf.setQ(Q);
    kf.setH(H);
    kf.setR(R);
    SimpleMatrix x = new SimpleMatrix(new double[][] { 
      { (float)center.getX() }, 
      { (float)center.getY() },
      { 0 },
      { 0 }
    });
    kf.setState(x);




}
public void initializeKalmanFilter(float[][] transitionMatrix, float[][] measurementMatrix, float[][] processNoiseCovariance, float[][] measurementNoiseCovariance) {
    kf = new KalmanFilter(transitionMatrix.length, measurementMatrix.length);
    kf.setF(new SimpleMatrix(transitionMatrix));
    kf.setH(new SimpleMatrix(measurementMatrix));
    kf.setQ(new SimpleMatrix(processNoiseCovariance));
    kf.setR(new SimpleMatrix(measurementNoiseCovariance));
}

public SimpleMatrix predictKalmanFilter() {
    return kf.predict();
}

public SimpleMatrix correctKalmanFilter(float[] measurement) {
    SimpleMatrix z = new SimpleMatrix(measurement.length, 1, true, measurement);
    return kf.correct(z);
}

public SimpleMatrix getKalmanFilterState() {
    return kf.getState();
}

public void setKalmanFilterState(float[] state) {
    SimpleMatrix x = new SimpleMatrix(state.length, 1, true, state);
    kf.setState(x);
}

public void updateWithKalmanFilter(TrackBlob previousBlob) {
    SimpleMatrix x = previousBlob.getKalmanFilterState();
    setKalmanFilterState(x.getMatrix().getData());
    update(previousBlob);
}

public void setLocation(Point2D location) {
    center = location;
}

public void addPoint(LidarPoint blPt) {
    blobPoints.add(blPt);
    allPoints.append(new Ellipse2D.Double(blPt.world.getX(),blPt.world.getY(),1,1),true);
    totalPoints++;

    boundingBox = allPoints.getBounds2D();
    center = new Point2D.Double(boundingBox.getCenterX(),boundingBox.getCenterY());
    locationHistory.add(0, center);  // add new position to the beginning of the list
 
    if (locationHistory.size() > 2) {
      locationHistory.remove(locationHistory.size() - 1);  // remove the oldest position

    }
   
}


public void display(float drawScale, boolean drawPoints, boolean drawBox, boolean drawHistory, int fColor)
{


life = (millis()-birthDay)/1000.0f;


if(locationHistory.size()>1)
{
    
    

    if (locationHistory.size() > 1 && drawVelocity) {
    Point2D currentPoint = locationHistory.get(0);
    Point2D previousPoint = locationHistory.get(1);
    drawVelocityArrow(currentPoint, previousPoint, 2, 200, drawScale, fColor);

    distanceTraveled = calcDistance(locationHistory)/1000;  
    velocity = distanceTraveled/life;
  }



}



lastUpdate=millis();


rectMode(CORNER);
stroke(fColor);
strokeWeight(1);
fill(0,255,0,100);
rect((float)boundingBox.getX()*drawScale,(float)boundingBox.getY()*drawScale,(float)boundingBox.getWidth()*drawScale,(float)boundingBox.getHeight()*drawScale);
//noStroke();
noFill();
ellipse((float)center.getX()*drawScale,(float)center.getY()*drawScale,10,10);

if(drawLabel)
{
fill(fColor);
    textSize(22);
    textAlign(CENTER,CENTER);
    text("X: "+(round((float)center.getX())+" | Y: "+round((float)center.getY())),(float)center.getX()*drawScale,((float)center.getY()*drawScale)-20);
    textSize(40);
    text(blobNumber+" / "+name,(float)center.getX()*drawScale,((float)center.getY()*drawScale)+0);
    textSize(30);
    text("active time: "+roundTo(life,1)+" / Metres: "+roundTo(distanceTraveled,2),(float)center.getX()*drawScale,((float)center.getY()*drawScale)+35);
    //text(distanceTraveled+" "+life+" "+velocity,(float)center.getX()*drawScale,((float)center.getY()*drawScale)+60);
}
if(drawHistory)
{
    stroke(fColor);
    strokeWeight(1);
    for(int hist = locationHistory.size()-1;hist>0;hist--)
    {
        line((float)locationHistory.get(hist).getX()*drawScale,(float)locationHistory.get(hist).getY()*drawScale,(float)locationHistory.get(hist-1).getX()*drawScale,(float)locationHistory.get(hist-1).getY()*drawScale);
        
    }

}




}


public void update(TrackBlob closestPrev)
{
name = closestPrev.name;
locationHistory.addAll(closestPrev.locationHistory);
birthDay = closestPrev.birthDay;
blobNumber = closestPrev.blobNumber;
}

public float calcDistance(ArrayList<Point2D> allPoints)
{
    float totalDis = 0;
    for(int i=0;i<allPoints.size()-1;i++)
    {
    float checkDis = (float)allPoints.get(i).distance(allPoints.get(i+1));    
    if(checkDis<distanceTrackCalibration){checkDis=0;}
    totalDis+=checkDis;
    }

return totalDis;
}


public void assignID()
{
 int newNumber = blobID++;
 blobNumber = newNumber;


}


public void drawVelocityArrow(Point2D currentPoint, Point2D previousPoint, float distanceThreshold, float arrowSize, float drawScale, int arrowColor) {
  float distance = (float) currentPoint.distance(previousPoint);
  
    PVector direction = new PVector((float) (currentPoint.getX() - previousPoint.getX()), (float) (currentPoint.getY() - previousPoint.getY()));
    float arrowAngle = degrees(direction.heading());

    println(arrowAngle);

}


}


public class KalmanFilter {
  
  private SimpleMatrix x; // state estimate
  private SimpleMatrix P; // error covariance
  private SimpleMatrix F; // state transition matrix
  private SimpleMatrix Q; // process noise covariance
  private SimpleMatrix H; // measurement matrix
  private SimpleMatrix R; // measurement noise covariance

  public KalmanFilter(int stateSize, int measurementSize) {
    x = new SimpleMatrix(stateSize, 1);
    P = SimpleMatrix.identity(stateSize);
    F = SimpleMatrix.identity(stateSize);
    Q = SimpleMatrix.identity(stateSize);
    H = new SimpleMatrix(measurementSize, stateSize);
    R = SimpleMatrix.identity(measurementSize);
  }

  public void setF(SimpleMatrix F) {
    this.F = F;
  }

  public void setQ(SimpleMatrix Q) {
    this.Q = Q;
  }

  public void setH(SimpleMatrix H) {
    this.H = H;
  }

  public void setR(SimpleMatrix R) {
    this.R = R;
  }

  public SimpleMatrix getState() {
    return x;
  }

  public void setState(SimpleMatrix x) {
    this.x = x;
  }

  public SimpleMatrix predict() {
    x = F.mult(x);
    P = F.mult(P).mult(F.transpose()).plus(Q);
    return x;
  }

  public SimpleMatrix correct(SimpleMatrix z) {
    SimpleMatrix y = z.minus(H.mult(x));
    SimpleMatrix S = H.mult(P).mult(H.transpose()).plus(R);
    SimpleMatrix K = P.mult(H.transpose().mult(S.invert()));
    x = x.plus(K.mult(y));
    P = SimpleMatrix.identity(x.numRows()).minus(K.mult(H)).mult(P);
    return x;
  }
  
}
class TrackPoly
{
ArrayList<PolyPoint> pList = new ArrayList<PolyPoint>();
Polygon trackArea;
    TrackPoly()
    {
        trackArea = new Polygon();
    }

    public void addPoint(int pointX, int pointY, float sf)
    {
        int x = round(pointX/sf);
        int y = round(pointY/sf);    
        pList.add(new PolyPoint(x,y));
        trackArea.addPoint(x,y);
    }
    public void addSavedPoint(int x, int y)
    {
        pList.add(new PolyPoint(x,y));
        trackArea.addPoint(x,y);

    }
    public void display(float drawScale, int polyColor)
    {
        strokeWeight(1);
        fill(polyColor);
       
        PShape trackPoly = createShape();
        trackPoly.beginShape();
        trackPoly.stroke(polyColor);
        trackPoly.strokeWeight(2);
        trackPoly.noFill();
        for(PolyPoint p : pList)
        {
            ellipse(p.worldX*drawScale,p.worldY*drawScale,10,10);
            trackPoly.vertex(p.worldX*drawScale,p.worldY*drawScale);
        }
        trackPoly.endShape(CLOSE);
        shape(trackPoly,0,0);

    }
    public void sendPoints()
    {
        OscMessage trackArea = new OscMessage("/trackArea");
        trackArea.add(pList.size());
        for(PolyPoint p : pList)
        {
          trackArea.add(p.worldX);
          trackArea.add(p.worldY);  
        }

    lidarFeed1.send(trackArea,broadcastList);

    }



}
class SensorZone
{
ArrayList<PolyPoint> pList = new ArrayList<PolyPoint>();
Polygon trackArea;
int population = 0;
ArrayList<TrackBlob> insideBlobs = new ArrayList<TrackBlob>();
boolean hitAny;
float centerX;
float centerY;
int sNumber;
IntList currentMembers = new IntList();

    SensorZone(int sNum)
    {
        trackArea = new Polygon();
        sNumber = sNum;
    }

    public void addPoint(int pointX, int pointY, float sf)
    {
        int x = round(pointX/sf);
        int y = round(pointY/sf);    
        pList.add(new PolyPoint(x,y));
        trackArea.addPoint(x,y);
        getCenter();
    }
    public void addSavedPoint(int x, int y)
    {
        pList.add(new PolyPoint(x,y));
        trackArea.addPoint(x,y);
        getCenter();

    }
    public void display(float drawScale, int polyColor, int hitColor, PointStream ps)
    {
        
        currentMembers.clear();    
        hitAny = false;
        int tempCount = 0;
        ArrayList<TrackBlob> checkBlobs = ps.currentBlobs; 
        for(TrackBlob cb : checkBlobs)
        {
            if(trackArea.intersects(cb.boundingBox))
            {
                //println("hit :"+cb.name);
                tempCount++;
                hitAny=true;
                currentMembers.append(cb.blobNumber);
            }
            population=tempCount;
        }
        
        
        
        strokeWeight(1);
        fill(polyColor);
       
        PShape trackPoly = createShape();
        trackPoly.beginShape();
        trackPoly.stroke(polyColor);
        trackPoly.strokeWeight(2);
        if(hitAny){trackPoly.fill(hitColor);}
        else{trackPoly.noFill();}
        
        
        for(PolyPoint p : pList)
        {
            ellipse(p.worldX*drawScale,p.worldY*drawScale,10,10);
            trackPoly.vertex(p.worldX*drawScale,p.worldY*drawScale);
        }
        trackPoly.endShape(CLOSE);       
        
        shape(trackPoly,0,0);

        fill(0);
        textSize(30);
        textAlign(CENTER,CENTER);
        text("zone "+sNumber+" : "+population,centerX*displayscaleFactor,centerY*displayscaleFactor);

        OscMessage sensorArea = new OscMessage("/sensorZones/"+sNumber);
        sensorArea.add(population);//0

        for(int bNums : currentMembers)
        {
            sensorArea.add(bNums);
        }
        lidarFeed1.send(sensorArea,broadcastList);

    }

    public void getCenter()
    {
        float tempX = 0;
        float tempY = 0;
        for(PolyPoint p : pList)
        {
            tempX+=p.worldX;
            tempY+=p.worldY;
        }
        centerX = tempX/pList.size();
        centerY = tempY/pList.size();


    }
    public void sendPoints()
    {
        OscMessage trackArea = new OscMessage("/trackArea");
        trackArea.add(pList.size());
        for(PolyPoint p : pList)
        {
          trackArea.add(p.worldX);
          trackArea.add(p.worldY);  
        }

    lidarFeed1.send(trackArea,broadcastList);

    }



}


class TrackWindow
{
ArrayList<PolyPoint> pList = new ArrayList<PolyPoint>();
Polygon trackArea;
int resolutionX;
int resolutionY;

ArrayList<TrackBlob> insideBlobs = new ArrayList<TrackBlob>();

    TrackWindow(int inResX, int inResY)
    {
        trackArea = new Polygon();
        resolutionX = inResX;
        resolutionY = inResY;
    }

    public void addPoint(int pointX, int pointY, float sf)
    {
        int x = round(pointX/sf);
        int y = round(pointY/sf);    
        pList.add(new PolyPoint(x,y));
        trackArea.addPoint(x,y);
    }
    public void addSavedPoint(int x, int y)
    {
        pList.add(new PolyPoint(x,y));
        trackArea.addPoint(x,y);

    }
    public void display(float drawScale, int polyColor, PointStream ps)
    {
        ArrayList<TrackBlob> checkBlobs = ps.currentBlobs;
        insideBlobs.clear(); 
        for(TrackBlob cb : checkBlobs)
        {
            if(trackArea.contains(cb.center))
            {
               
            insideBlobs.add(cb);
            }
        }
        
        
        strokeWeight(1);
        fill(polyColor);
       
        PShape trackPoly = createShape();
        trackPoly.beginShape();
        trackPoly.stroke(polyColor);
        trackPoly.strokeWeight(2);
        trackPoly.noFill();
        for(PolyPoint p : pList)
        {
            ellipse(p.worldX*drawScale,p.worldY*drawScale,10,10);
            trackPoly.vertex(p.worldX*drawScale,p.worldY*drawScale);
        }
        trackPoly.endShape(CLOSE);
        shape(trackPoly,0,0);

    }
    public void sendPoints()
    {
        OscMessage trackWindowM = new OscMessage("/trackWindow");
        trackWindowM.add(insideBlobs.size());
        for(TrackBlob tb : insideBlobs)
        {
         int relX = round(map(((float)tb.center.getX()-pList.get(0).worldX),0,(pList.get(1).worldX-pList.get(0).worldX),0,resolutionX));   
         int relY = round(map(((float)tb.center.getY()-pList.get(0).worldY),0,(pList.get(3).worldY-pList.get(0).worldY),0,resolutionY));
        trackWindowM.add(relX);
        trackWindowM.add(relY);
        println(relX+"\t"+relY);
        }

    lidarFeed1.send(trackWindowM,broadcastList);

    }



}

class PolyPoint
{
int worldX;
int worldY;
PolyPoint(int _x, int _y)
{
    worldX=_x;
    worldY=_y;
}


}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "lidarTrackingServer_v061" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
